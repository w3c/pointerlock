<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Pointer Lock 2.0
    </title>
    <meta charset="utf-8"><!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->

    <script src='https://www.w3.org/Tools/respec/respec-w3c' class=
    'remove'></script>
    <script class='remove'>
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "ED",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        caniuse: "pointerlock",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        //publishDate:  "2011-01-01",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        // copyrightStart: "2005"

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        previousPublishDate: "2019-05-30",
        previousMaturity: "FPWD",

        testSuiteURI:
          "https://github.com/web-platform-tests/wpt/tree/master/pointerlock",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          {
            name: "Navid Zolghadr",
            company: "Google",
            companyURL: "http://www.google.com/",
            w3cid: "92361",
          },
          {
            name: "Mustaq Ahmed",
            company: "Google",
            companyURL: "http://www.google.com/",
            w3cid: "75206",
          },
        ],
        formerEditor: [
          {
            name: "Vincent Scheib",
            url: "http://www.scheib.net",
            company: "Google",
            companyURL: "http://www.google.com/",
          },
        ],
        github: "w3c/pointerlock",
        group: "webapps",
        xref: {
                specs: ["uievents"],
                profile: "web-platform",
        },
      };

    </script>
  </head>
  <body data-cite="uievents">
    <section id='abstract'>
      This specification defines an API that provides scripted access to raw
      mouse movement data while locking the target of mouse events to a single
      element and removing the cursor from view. This is an essential input
      mode for certain classes of applications, especially first person
      perspective 3D applications and 3D modeling software.
    </section>
    <section id="sotd">
      <!-- Status of This Document -->
      <p>
        A history of changes to this document can be found at <a href=
        "https://github.com/w3c/pointerlock/commits/gh-pages/index.html">https://github.com/w3c/pointerlock/commits/gh-pages/index.html</a>
      </p>
      <p>
        Summary of changes since <a href=
        "https://www.w3.org/TR/2016/WD-pointerlock-2-20161122/">W3C
        Recommendation 27 October 2016</a>:
      </p>
      <ul>
        <li>
          <a href=
          "https://github.com/w3c/pointerlock/commit/027f57ae80cf5bdb03379203828aa234f3e7e433">
          IDL blocks updated</a> to be machine <a href=
          "https://github.com/w3c/pointerlock/issues/13">parsable</a>, no
          substantive change.
        </li>
      </ul>
    </section>
    <section id='introduction' class='informative'>
      <h2>
        Introduction
      </h2>
      <p>
        The Pointer Lock API provides applications the ability to directly
        interpret mouse movements as an input method, rather than being limited
        to only read the position of the mouse cursor. A popular example is
        that of first person movement controls in three dimensional graphics
        applications such as games: movement of the mouse is interpreted to
        control the rotation/direction of the player's camera; no mouse cursor
        is displayed, and the movement is not limited to the traditional
        boundaries (such as the user agent's window, or the overall screen)
        that the mouse cursor is usually subject to, meaning that any mouse
        movements can be tracked indefinitely in any direction.
      </p>
      <p>
        Pointer Lock is related to Mouse Capture [[MDN-SETCAPTURE]] (Mouse
        Capture is unspecified: bug <a href=
        "https://www.w3.org/Bugs/Public/show_bug.cgi?id=14600">14600</a>).
        Capture provides continued event delivery to a target element while a
        mouse is being dragged, but ceases when the mouse button is released.
        Pointer Lock differs by being persistent, not limited by screen
        boundaries, sending events regardless of mouse button state, hiding the
        cursor, and not releasing until an API call or specific <a>default
        unlock gesture</a> by the user.
      </p>
      <p>
        Pointer Lock deals with capturing a single resource and relating it to
        a single element. This is similar to the Fullscreen API [[FULLSCREEN]],
        which promotes a single element to be full screen. The Pointer Lock API
        chooses to pattern the resource capture, state change, and release API
        as closely as possible after the Fullscreen API.
      </p>
      <p>
        The Pointer Lock interaction mode was previously referred to as mouse
        lock. The name was changed as many different controller types besides
        mice can manipulate the on screen pointing cursor, and they are all
        impacted.
      </p>
    </section>
    <section>
      <h2>
        Glossary
      </h2>
      <dl>
        <dt>
          <dfn>Engagement gesture</dfn>
        </dt>
        <dd>
          An event generated by the user agent as a result of user interaction
          processed by the user agent to interact with the page. e.g. `click`,
          but not `mousemove`. Engagement gestures are any events included in
          the definition of being triggered by [=user activation=] with the
          addition of `keypress` and `keyup`. Note that operating system level
          accessibility and internationalization features may intercept
          gestures before the user agent processes them for interaction with a
          page. E.g. multiple key press codes used to enter an extended
          international character.
        </dd>
      </dl>
    </section>
    <section>
      <h2>
        Pointer Lock and Interfaces
      </h2>
      <section>
        <h3>
          The <dfn>pointer lock state</dfn> definition
        </h3>
        <p>
          The [=pointer lock state=] is the state where a single DOM element,
          which we will call the <dfn>pointer-lock target</dfn>, receives all
          mouse events and the cursor is hidden.
        </p>
        <p>
          Once in the [=pointer lock state=] the [=user agent=] has a
          [=pointer-lock target=], a <dfn>pointer-lock options</dfn>, which is
          a {{PointerLockOptions}} and a <dfn>cursor position</dfn> which is a
          pair of numbers representing the location of the system mouse cursor
          when the Pointer Lock State was entered (the same location that is
          reported in `screenX`, `screenY`). The [=pointer-lock target=]
          receives all relevant user generated {{MouseEvent}} events: namely,
          all user-generated `mousemove`, `mousedown`, `mouseup`, `click`,
          `dblclick`, `auxclick`, and `wheel` [[ui-events]]. No other elements
          receive these events while in [=pointer lock state=]. There will be
          no dispatching of events that require the concept of a mouse cursor:
          namely, `mouseenter`, `mouseleave`, `mouseover`, `mouseout`, `drag`,
          and `drop`.
        </p>
        <p>
          While in the [=pointer lock state=] if the [=pointer-lock options=]'
          {{PointerLockOptions/unadjustedMovement}} member is `true` the event
          coordinates shall not be affected by the underlying platform
          behaviors such as mouse acceleration. In other words, the user agent
          uses the APIs provided by the underlying platform to guarantee
          getting the raw events. If the {{PointerLockOptions}}'
          {{PointerLockOptions/unadjustedMovement}} member is `false` The user
          agent relies on the default behavior of the underlying platform
          regarding the mouse acceleration.
        </p>
        <p>
          In the [=pointer lock state=], the system mouse cursor is hidden and
          the window is prevented from losing focus, regardless of mouse
          movement or button presses. This is directly or indirectly achieved
          utilizing the underlying operating system API.
        </p>
        <p class="note">
          Synthetic mouse events created by application script act the same
          regardless of lock state.
        </p>
      </section>
      <section data-dfn-for="PointerLockOptions">
        <h3>
          `PointerLockOptions` dictionary
        </h3>
        <pre class="idl">
          dictionary PointerLockOptions {
            boolean unadjustedMovement = false;
          };
        </pre>
        <dl>
          <dt>
            <dfn>PointerLockOptions</dfn> dictionary
          </dt>
          <dd>
            <p>
              The options dictionary to customize how the pointer behaves in
              the locked mode.
            </p>
          </dd>
          <dt>
            <dfn>unadjustedMovement</dfn> member
          </dt>
          <dd>
            <p>
              If this value is set to `true`, then the pointer movements will
              not be affected by the underlying platform modifications such as
              mouse accelaration.
            </p>
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          `pointerlockchange` and `pointerlockerror` Events
        </h3>
        <p>
          Two events are used to communicate pointer lock state change or an
          error in changing state. They are named <dfn class=
          "event">pointerlockchange</dfn> and <dfn class=
          "event">pointerlockerror</dfn>. If pointer lock is entered or exited
          for any reason a {{Document/pointerlockchange}} event must be sent.
        </p>
        <p>
          The [=user agents=] must deliver these events by <a data-lt=
          "queue a task">queuing a task</a> to [=fire an event=] of the
          appropriate name with its {{Event/bubbles}} set to false to the
          pointer lock [=Event/target=] element's [=Node/node document=]. Refer
          to algorithm of [[[#requestPointerLock]]] for detail.
        </p>
        <p class="note">
          Magnification software increases the size of content on the screen.
          It uses the mouse to move the magnified point of focus around. When a
          pointer lock is initiated, the magnification software needs to switch
          to using the keyboard to move the magnified point of focus around
          instead. When a {{pointerlockchange}} event is fired, web browsers
          therefore need to make sure the event is communicated to assistive
          technologies like screen magnifiers.
        </p>
      </section>
      <section>
        <h3>
          <dfn>Exit Pointer Lock</dfn>
        </h3>
        <p>
          The process of exiting pointer lock, given an |element:Element|, is
          as follows:
        </p>
        <ol class="algorithm">
          <li>The system mouse cursor must be displayed again and positioned at
          [=cursor position=].
          </li>
          <li>[=Queue an element task=] on the [=user interaction task source=]
          to [=fire an event=] named {{pointerlockchange}} at the given
          |element:Element|'s [=Node/node document=].
          </li>
          <li>Exit the [=pointer lock state=] by setting [=pointer-lock
          target=], [=pointer-lock options=], and [=cursor position=] to null.
          </li>
        </ol>
      </section>
    </section>
    <section data-dfn-for="Element" data-link-for="Element" id=
    "requestPointerLock">
      <h2>
        Extensions to the `Element` Interface
      </h2>
      <p>
        The {{Element}} interface is extended to provide the ability to request
        the pointer be locked.
      </p>
      <pre class="idl">
        partial interface Element {
          Promise&lt;undefined&gt; requestPointerLock(optional PointerLockOptions options = {});
        };
      </pre>
      <pre class='example'>
        const lock_element = document.getElementById("lock_element");
        const lock_button = document.getElementById("lock");
        lock_button.addEventListener("click", async (event) =&gt; {
            try {
                await lock_element.requestPointerLock({ unadjustedMovement: true });
                console.log("successfully locked!");
            } catch (e) {
                console.log("lock failed with error: ", e);
            }
        });
    </pre>
      <dl>
        <dt>
          requestPointerLock({{PointerLockOptions}} <dfn>options</dfn>) method
        </dt>
        <dd>
          <p>
            When <dfn>requestPointerLock()</dfn> invoked, perform the following
            steps:
          </p>
          <ol class="algorithm">
            <li>Let |promise:Promise| be [=a new promise=].
            </li>
            <li>When a {{Window/window}} is in [=Window/focus=], if the [=this=]'s
            [=shadow-including root=] is the [=navigable/active document=] of a
            [=Document/browsing context=] (or has an [=tree/ancestor=]
            [=browsing context=]) which is not in focus:
              <ol>
                <li>[=Queue an element task=] on the [=user interaction task
                source=], given [=this=], to perform the following steps:
                  <ol>
                    <li>[=Fire an event=] named {{pointerlockerror}} at
                    [=this=]'s [=Node/node document=].
                    </li>
                    <li>[=Reject=] |promise| with a {{"WrongDocumentError"}}
                    {{DOMException}}.
                    </li>
                  </ol>
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
            </li>
            <li>If the user agent's [=pointer-lock target=] is an element whose
            [=shadow-including root=] is not equal to [=this=]'s
            [=shadow-including root=], then:
              <ol>
                <li>[=Queue an element task=] on the [=user interaction task
                source=], given this, to perform the following steps:
                  <ol>
                    <li>[=Fire an event=] named {{pointerlockerror}} at
                    [=this=]'s [=Node/node document=].
                    </li>
                    <li>[=Reject=] <var>promise</var> with a
                    "{{InvalidStateError}}" {{DOMException}}.
                    </li>
                  </ol>
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
            </li>
            <li>If the user agent's [=pointer-lock target=]'s
            [=shadow-including root=] is equal to [=this=]'s [=shadow-including
            root=], then:
              <ol>
                <li>If [=options=] are equivalent to the current [=pointer-lock
                options=]
                  <ol>
                    <li>Set [=pointer-lock target=] to [=this=]
                    </li>
                    <li>[=Queue an element task=] on the [=user interaction
                    task source=], given this, to perform the following steps:
                      <ol>
                        <li>[=Fire an event=] named {{pointerlockchange}} at
                        [=this=]'s [=Node/node document=].
                        </li>
                        <li>[=Resolve=] the <var>promise</var>.
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li>If [=options=] are not equivalent to the user agent's
                current [=pointer-lock options=] and [=options=] are not
                supported:
                  <ol>
                    <li>[=Queue an element task=] on the [=user interaction
                    task source=], given this, to perform the following steps:
                      <ol type='i'>
                        <li>[=Reject=] <var>promise</var> with a
                        "{{NotSupportedError}}" {{DOMException}}.
                        </li>
                      </ol>
                    </li>
                    <li>Return <var>promise</var>.
                    </li>
                  </ol>
                </li>
                <li>If [=options=] are not equivalent to the current
                [=pointer-lock options=] and [=options=] are supported then
                perform the following steps
                  <ol>
                    <li>Update the user agent's [=pointer-lock target=] to this
                    element.
                    </li>
                    <li>Update the user agent's [=pointer-lock options=] to
                    [=options=]
                    </li>
                    <li>[=Queue an element task=] on the [=user interaction
                    task source=], given this, to perform the following steps:
                      <ol>
                        <li>[=Fire an event=] named {{pointerlockchange}} at
                        [=this=]'s [=Node/node document=].
                        </li>
                        <li>The <var>promise</var> must be resolved.
                        </li>
                      </ol>
                    </li>
                    <li>Return <var>promise</var>.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>If the request was not started from an [=engagement gesture=]
            and the {{Document}} has not previously released a successful
            Pointer Lock with {{Document/exitPointerLock()}}:
              <ol>
                <li>[=Queue an element task=] on the [=user interaction task
                source=], given this, to perform the following steps:
                  <ol type='i'>
                    <li>[=Fire an event=] named {{pointerlockerror}} at
                    [=this=]'s [=Node/node document=].
                    </li>
                    <li>[=Reject=] <var>promise</var> with a
                    "{{NotAllowedError}}" {{DOMException}}.
                    </li>
                  </ol>
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
              <aside class="note">
                <p>
                  This ensures a user can leave a document that constantly
                  attempts to lock the pointer. The document will be blocked
                  from locking upon initial navigation or re-acquiring lock
                  unless the user re-engages directly with the document.
                </p>
                <p>
                  Conversely, if pointer lock is exited via
                  {{Document/exitPointerLock()}} no [=engagement gesture=] is
                  required to reenter pointer lock. This enables applications
                  that frequently move between interaction modes, and ones that
                  may do so based on a timer or remote network activity.
                </p>
                <p>
                  Pointer lock is commonly combined with fullscreen
                  [[FULLSCREEN]], and if an [=engagement gesture=] is used to
                  enter fullscreen it is sufficient for a subsequent
                  {{Element/requestPointerLock()}}.
                </p>
              </aside>
            </li>
            <li>If [=this=]'s [=Node/node document=]'s [=Document/active
            sandboxing flag set=] has the [=sandboxed pointer lock browsing
            context flag=] set:
              <ol>
                <li>[=Queue an element task=] on the [=user interaction task
                source=], given this, to perform the following steps:
                  <ol type='i'>
                    <li>[=Fire an event=] named {{pointerlockerror}} at
                    [=this=]'s [=Node/node document=].
                    </li>
                    <li>[=Reject=] <var>promise</var> with a
                    "{{SecurityError}}" {{DOMException}}.
                    </li>
                  </ol>
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
            </li>
            <li>If [=options=]["{{PointerLockOptions/unadjustedMovement}}"] is
            true and the platform does not support
            {{PointerLockOptions/unadjustedMovement}}:
              <ol>
                <li>[=Queue an element task=] on the [=user interaction task
                source=], given this, to perform the following steps:
                  <ol type='i'>
                    <li>[=Fire an event=] named {{pointerlockerror}} at
                    [=this=]'s [=Node/node document=].
                    </li>
                    <li>[=Reject=] <var>promise</var> with a
                    "{{NotSupportedError}}" {{DOMException}}.
                    </li>
                  </ol>
                </li>
                <li>Return <var>promise</var>.
                </li>
              </ol>
              <aside class="note" data-link-for="Document">
                "{{NotSupportedError}}" {{DOMException}} should be reserved for
                unsupported options in future iterations of this spec. That is,
                no other error conditions should use "{{NotSupportedError}}",
                so that web developers can use it for feature testing.
              </aside>
            </li>
            <li>If none of the above errors have occured
              <ol>
                <li>Enter [=pointer lock state=] by performing the following:
                  <ol>
                    <li>Set the user agent's [=pointer-lock target=] to
                    [=this=].
                    </li>
                    <li>Set the user agent's [=cursor position=] to the current
                    system mouse location.
                    </li>
                    <li>Set the [=pointer-lock options=] to [=options=].
                    </li>
                  </ol>
                </li>
                <li>[=Queue an element task=] on the [=user interaction task
                source=], given this, to perform the following steps:
                  <ol>
                    <li>[=Fire an event=] named {{pointerlockchange}} at
                    [=this=]'s [=Node/node document=].
                    </li>
                    <li>[=Resolve=] the <var>promise</var>.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Return <var>promise</var>.
            </li>
          </ol>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="Document" data-link-for="Document">
      <h2>
        Extensions to the `Document` Interface
      </h2>
      <pre class="idl">
        partial interface Document {
          attribute EventHandler onpointerlockchange;
          attribute EventHandler onpointerlockerror;
          undefined exitPointerLock();
        };
      </pre>
      <dl>
        <dt>
          <dfn>onpointerlockchange</dfn> attribute
        </dt>
        <dd>
          <p>
            An [=event handler idl attribute=] for
            {{Document/pointerlockchange}} events.
          </p>
        </dd>
        <dt>
          <dfn>onpointerlockerror</dfn> attribute
        </dt>
        <dd>
          <p>
            An [=event handler idl attribute=] for
            {{Document/pointerlockerror}} events.
          </p>
        </dd>
        <dt>
          <dfn>exitPointerLock()</dfn> method
        </dt>
        <dd>
          <ol>
            <li>If the user agent's pointer-lock target is null, then return.
            </li>
            <li>If [=pointer-lock target=]'s [=shadow-including root=]is not
            equal to [=this=]'s [=Node/node document=], return.
            </li>
            <li>[=Exit pointer lock=] with the user agent's [=pointer-lock
            target=].
            </li>
          </ol>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="DocumentOrShadowRoot">
      <h2>
        Extensions to the `DocumentOrShadowRoot` Mixin
      </h2>
      <pre class="idl">
        partial interface mixin DocumentOrShadowRoot {
          readonly attribute Element? pointerLockElement;
        };
      </pre>
      <dl>
        <dt>
          <dfn>pointerLockElement</dfn>
        </dt>
        <dd>
          <p>
            While the pointer is locked, returns the result of [=retargeting=]
            the element, which is the target for mouse events, against [=this=]
            element if the result and [=this=] element are in the same tree,
            otherwise returns null.
          </p>
          <p>
            Returns null if lock is pending or if pointer is unlocked.
          </p>
          <pre class='example' id="example-retarget-pointerlock">
              &lt;body&gt;
                &lt;div id="host1"&gt;
                  &lt;shadow-root id="root1"&gt;
                    &lt;canvas id="canvas1"&gt;&lt;/canvas&gt;
                  &lt;/shadow-root&gt;
                &lt;/div&gt;
                &lt;div id="host2"&gt;
                  &lt;shadow-root id="root2"&gt;
                    &lt;canvas id="canvas2"&gt;&lt;/canvas&gt;
                  &lt;/shadow-root&gt;
                &lt;/div&gt;
              &lt;/body&gt;
          </pre>
          <p>
            Note: the example uses fictional `shadow-root` element to denote a
            [=Element/shadow root=] instance.
          </p>
          <p>
            If `#canvas1` is the target, `document.pointerLockElement` returns
            `#host1`, and `root1.pointerLockElement` returns `#canvas1`. The
            result of [=retargeting=] `#canvas1` against `#root2` is `#host1`,
            but as `#host1` is not in the same tree as `#root2`, null will be
            returned for `root2.pointerLockElement`.
          </p>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="MouseEvent" data-link-for="MouseEvent" data-cite=
    "ui-events">
      <h2>
        Extensions to the `MouseEvent` Interface
      </h2>
      <pre class="idl">
        partial interface MouseEvent {
          readonly attribute double movementX;
          readonly attribute double movementY;
        };
      </pre>
      <dl>
        <dt>
          <dfn>movementX</dfn> attribute
        </dt>
        <dt>
          <dfn>movementY</dfn> attribute
        </dt>
        <dd>
          <p>
            The attributes {{movementX}} and {{movementY}} must provide the
            change in position of the pointer, as if the values of `screenX`,
            `screenY`, were stored between two subsequent `mousemove` events
            `eNow` and `ePrevious` and the difference taken `movementX =
            eNow.screenX - ePrevious.screenX`.
          </p>
          <p>
            {{movementX}} and {{movementY}} must be zero for all mouse events
            except `mousemove`. All motion data must be delivered via
            `mousemove` events such that between any two mouse events
            `earlierEvent` and `currentEvent` the value of
            `currentEvent.screenX - earlierEvent.screenX` is equivalent to the
            sum of all {{movementX}} in the events after `earlierEvent`, with
            the exception of when screenX can not be updated because the
            pointer is clipped by the [=user agent=] screen boundaries.
          </p>
          <p>
            {{movementX}} and {{movementY}} must be updated regardless of
            pointer lock state.
          </p>
          <p>
            When unlocked, the system cursor can exit and re-enter the [=user
            agent=] window. If it does so and the [=user agent=] was not the
            target of operating system mouse move events then the most recent
            pointer position will be unknown to the [=user agent=] and
            {{movementX}} / {{movementY}} can not be computed and must be set
            to zero.
          </p>
          <p>
            When pointer lock is enabled `clientX`, `clientY`, `screenX`, and
            `screenY` must hold constant values as if the pointer did not move
            at all once pointer lock was entered. But {{movementX}} and
            {{movementY}} must continue to provide the change in position of
            the pointer as when the pointer is unlocked. There will be no limit
            to {{movementX}} and {{movementY}} values if the mouse is
            continuously moved in a single direction. The concept of the mouse
            cursor will have been removed, and it will not move off the window
            or be clamped by a screen edge.
          </p>
          <p>
            The un-initialized value of {{movementX}} and {{movementY}} must be
            `0`.
          </p>
          <p>
            Large movement values must not appear in situations when mouse
            input is interupted, such as the mouse cursor leaving the window
            and then re-entering at another location. If a [=user agent=]
            experiences a gap in receiving mouse input data from the operating
            system then the next generated `mousemove` event must have
            {{movementX}} and {{movementY}} set to `0`. These gaps may appear
            for example when the [=user agent=] receives a mouse leaving event
            at the window system API. As an exception mouse capture may allow
            the [=user agent=] to continue receiving mouse events when the
            cursor moves outside the window.
          </p>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="MouseEventInit" data-link-for="MouseEventInit"
    data-cite="ui-events">
      <h2>
        Extensions to the `MouseEventInit` Dictionary
      </h2>
      <pre class="idl">
        partial dictionary MouseEventInit {
          double movementX = 0;
          double movementY = 0;
        };
      </pre>
      <dl>
        <dt>
          <dfn>movementX</dfn> member
        </dt>
        <dt>
          <dfn>movementY</dfn> member
        </dt>
        <dd>
          The members {{movementX}} and {{movementY}} are used to initialize
          respective members of {{MouseEvent}}.
        </dd>
      </dl>
    </section>
    <section>
      <h2>
        Requirements
      </h2>
      <p>
        A <dfn>default unlock gesture</dfn> must always be available that will
        [=exit pointer lock=] with the [=user agent=]'s [=pointer-lock
        target=].
      </p>
      <aside class="note">
        <p>
          The ESC key is the recommended [=default unlock gesture=] for [=user
          agents=] with keyboard input. It is recommended that the unlock
          gesture also match any used to exit fullscreen [[FULLSCREEN]].
        </p>
      </aside>
      <p>
        Pointer lock must be exited if the [=pointer-lock target=] <a data-lt=
        "become disconnected">becomes disconnected</a>, or the [=user agent=],
        window, or tab loses focus. Moving focus between elements of
        [=navigable/active document=], including between [=Document/browsing
        contexts=] , does not [=exit pointer lock=]. E.g. using the keyboard to
        move focus between contents of frames or iframes will not exit.
      </p>
      <p>
        Pointer lock must not be exited when fullscreen [[FULLSCREEN]] is
        entered or exited unless the pointer is required to enable interaction
        with the [=user agent=] graphical user interface, the [=default unlock
        gesture=] was used to exit both fullscreen and pointer lock, or window
        or tab focus was lost.
      </p>
    </section>
    <section class='informative'>
      <h2>
        Use Cases
      </h2>
      <section>
        <h2>
          Relative view-port rotation of free moving virtual actors
        </h2>
        <p>
          A player on a first/third person game will need to control the
          view-port orientation. A widely used method is the use of mouse
          movements to control the viewing angle. This kind of application can
          use the Pointer Lock API to allow a complete freedom of control over
          the viewport's yaw and pitch even when the user is not pressing mouse
          buttons. Those buttons can be used for other actions while constantly
          providing navigation via mouse movement.
        </p>
      </section>
      <section>
        <h2>
          Free rotation of 3D models or panning of 2D layers
        </h2>
        <p>
          Users of a three dimensional modeling application will need to rotate
          models. A application can use the Pointer Lock API to enable the
          author to rotate the model freely in a drag operation without
          limiting motion. Without pointer lock a drag would stop providing
          motion data when the mouse cursor is limited by the edge of the
          screen.
        </p>
        <p>
          Similarly, absolute motion panning of a large two dimensional image
          could be permitted in a single drag operation without cursor / screen
          limits.
        </p>
      </section>
      <section>
        <h2>
          Relative movement of actors
        </h2>
        <p>
          A player on a fast reflexes game controls a paddle to bounce back a
          ball to the opponent, while allowing the same paddle to execute
          actions based on different mouse buttons being pressed. The
          application can use the Pointer Lock API to allow the player to react
          quickly without being concerned about the mouse cursor leaving the
          game play area and clicking another system application, thus breaking
          the game flow.
        </p>
      </section>
      <section>
        <h2>
          Jog movement over spinner controls
        </h2>
        <p>
          When modifying numerically magnitudes in applications sometimes the
          user will prefer to "drag" a numeric control by its button handles to
          increment or decrement the numeric value. E.g. a spinner with a
          number entry text box and arrows pointing up and down that can be
          clicked or dragged on to change the value. An application could use
          the Pointer Lock API to allow modifying the numeric values beyond
          what the logical screen bounds allow. The same could apply for a
          control that fast forwards or rewinds a video or audio stream like a
          "jog".
        </p>
      </section>
      <section>
        <h2>
          Synthetic cursor interaction with HTML DOM UI
        </h2>
        <p>
          Some games use a classical cursor, however they want it to be limited
          or controlled in some manner. E.g. limited to the bounds of the game,
          or movable by the game. Locking the pointer enables this if the
          application creates their own cursor. However HTML and DOM should
          still be available to use for user interface. Synthetic mouse events
          should be permitted to allow an application defined cursor to
          interact with DOM. E.g. the following code should permit a custom
          cursor to send click events while the pointer is locked:
        </p>
        <pre class='example'>
            document.addEventListener("click", function (e) {
              if (e._isSynthetic)
                return;
              // send a synthetic click
              var ee = document.createEvent("MouseEvents");
              ee._isSynthetic = true;
              x = myCursor.x;
              y = myCursor.y;
              ee.initMouseEvent("click", true, true, null, 1,
                                x + e.screenX - e.clientX,
                                y + e.screenY - e.clientY,
                                x,
                                y);
              var target = document.elementFromPoint(x, y);
              if (target)
                target.dispatchEvent(ee);
            });
        </pre>
        <p>
          Note that synthetic clicks may not be permitted by a [=user agent=]
          to produce the same default action as a non-synthetic click. However,
          application handlers can still take action and provide user interface
          with existing HTML & DOM mechanisms.
        </p>
      </section>
      <section>
        <h2>
          View-port panning by moving a mouse cursor against the bounds of a
          view-port.
        </h2>
        <p>
          Real Time Strategy games often use this technique. When the player
          moves the pointer to the view-port borders, if they "push" the border
          with a mouse movement, the view-port is panned over the game area
          according to how much they move the mouse. When moving the mouse
          cursor within the bounds of the view port it acts at is typically
          would on a system. Applications may choose to implement this using
          pointer lock and the previous use case of "Synthetic cursor
          interaction with HTML DOM UI" to bring cursor behavior completely
          under their control.
        </p>
      </section>
      <section>
        <h2>
          Game Lobby, timer based pointer lock
        </h2>
        <p>
          Games that use pointer lock may desire a traditional UI and system
          cursor while players prepare in a game lobby. Games usually start
          after a short timer when all players are ready. Ideally the game
          could then switch to pointer lock mode without a [=user activation=].
          Players should be able to seamlessly move from the game lobby into
          game navigation.
        </p>
      </section>
      <section>
        <h2>
          Game Portal
        </h2>
        <p>
          Game portals, and other sites such as Facebook and Google Plus, host
          games for users to play. These games may be hosted and served from a
          different origin from that of the portal site. Embedded games should
          be able to lock the pointer, even in non-full screen mode.
        </p>
      </section>
    </section>
    <section class='informative'>
      <h2>
        Security
      </h2>
      <p>
        Security Concerns:
      </p>
      <ul>
        <li>User actions may be misdirected to elements the user did not intend
        to interact with.
        </li>
        <li>Pointer Lock will remove the ability of a user to interact with [=
        user agent=] and operating system controls
        </li>
        <li>Pointer Lock can be called repeated by script after user exits
        pointer lock, blocking user from meaningful progress.
        </li>
        <li>Full screen exit instructions are displayed in some [=user agent=]s
        when the pointer is moved to the top of the screen. During pointer lock
        that gesture is not possible.
        </li>
      </ul>
      <p>
        Responses:
      </p>
      <ul>
        <li>The [=user agents=] may limit what security origins may lock the
        pointer.
        </li>
        <li>The [=user agents=] may prompt for confirmation before locking,
        this preference may be saved as a content setting.
        </li>
        <li>Escape will always be provided by a [=default unlock gesture=],
        e.g. Esc key.
        </li>
        <li>Persistent display of escape instructions can be provided.
        </li>
        <li>Repeated escapes of pointer lock can signal [=user agent=] to not
        re-lock the pointer without more specific user action, e.g. similar to
        how Chrome suppresses repeated alert() calls.
        </li>
        <li>Changing to new tabs, windows, or any other action that causes a
        page to lose focus will [=exit pointer lock=] with the [=user agent=]'s
        [=pointer-lock target=].
        </li>
        <li>Pointer lock can only be engaged when the window is in focus in the
        [=user agent=] and operating system.
        </li>
      </ul>
      <p>
        Recommendations:
      </p>
      <ul>
        <li>Esc key should [=exit pointer lock=] with the user agent's
        [=pointer-lock target=].
        </li>
        <li>Preferences per sub-domain can be used to allow or block pointer
        lock, similar to pop-up, geolocation, and fullscreen.
        </li>
      </ul>
      <p>
        Pointer lock is a required user interaction mode for certain
        application types, but carries a usability concern if maliciously used.
        An attacker could remove the ability for a user to control their mouse
        cursor on their system. [=user agents=] will prevent this by always
        providing a mechanism to [=exit pointer lock=], by informing the user
        of how, and by limiting how pointer lock can be entered.
      </p>
      <p>
        [=user agents=] will determine their own appropriate policies, which
        may be specialized per device or differ based on user options.
      </p>
    </section>
    <section class='informative'>
      <h2>
        Frequently Asked Questions
      </h2>
      <section>
        <h2>
          Why not merge with Mouse Capture: setCapture()?
        </h2>
        <p>
          Mouse Capture [[MDN-SETCAPTURE]] handles low security risk mouse
          event target lock for the duration of a mouse drag gesture. Pointer
          lock removes the concept of the cursor and directs all events to a
          given target. They are related, but different.
        </p>
        <p>
          If a browser implemented both, it would be reasonable to support a
          combination of traits: The security simplicity of "automatically
          release lock when mouse up" and the increased functionality of total
          control over mouse input and removal of the system cursor. The
          security trait would allow more permissive use of the feature for
          applications that only required a short burst of pointer lock during
          a drag event.
        </p>
        <p>
          This functionality is omitted from the initial version of this spec
          because it helps the minor use cases in windowed mode but we still do
          not have an implementation solving the major ones. And, to implement
          this a browser must implement both, which none does yet. It is not
          clear if this feature should live on .lock or on .setCapture. If both
          were implemented, either API could be augmented fairly easily to
          offer the hybrid functionality.
        </p>
      </section>
      <section>
        <h2>
          Why not repurpose MouseEvent's .clientX/Y .screenX/Y?
        </h2>
        <p>
          Even in non locked state, the delta values of mouse movement are
          useful. Changing the meaning of .client or .screen based on lock
          state would also cause easy errors in code not carefully monitoring
          the lock state.
        </p>
      </section>
      <section>
        <h2>
          Why use .movementX/Y instead of .deltaX/Y?
        </h2>
        <p>
          When the pointer is locked 'wheel' events should be sent to the
          [=pointer-lock target=] element just as 'mousemove' events are. There
          is a naming conflict with .deltaX/Y/Z as defined in <a href=
          "https://w3c.github.io/uievents/#events-wheelevents">DOM 3 'wheel'
          event</a>.
        </p>
      </section>
      <section id="why-bundle">
        <h2>
          Why bundle all functionality (hiding cursor, providing mouse deltas)
          instead of using CSS to hide the cursor, always providing delta
          values, and offering an API to restrict the cursor movement to a
          portion of the web page?
        </h2>
        <p>
          There are good motivations to provide a more fine grained approach.
          E.g. the use case "View-port panning by moving a mouse cursor against
          the bounds of a view-port" doesn't require hiding the mouse cursor,
          only bounding it and always having delta values available. Also, this
          specification defines the movement deltas to be taken from how the
          system mouse cursor moves, which incorporates operating system
          filtering and acceleration of the mouse movement data. Applications
          may desire access to a more raw form of movement data prior to
          adjustments appropriate for a mouse cursor. Also, raw data may
          provide better than pixel level accuracy for movement, as well as
          higher frequency updates. Providing the raw delta movement would also
          not require special permission or mode from a user, and for some set
          of applications that do not require bounding the cursor may reduce
          the security barriers and prompts needed.
        </p>
        <p>
          There are two justifications for postponing this finer grained
          approach. The first is a concern of specifying what units mouse
          movement data are provided in. This specification defines
          .movementX/Y precisely as the same values that could be recorded when
          the mouse is not under lock by changes in .screenX/Y. Implementations
          across multiple [=user agents=] and operating systems will easily be
          able to meet that requirement and provide application developers and
          users with a consistent experience. Further, users are expected to
          have already configured the full system of hardware input and
          operating system options resulting in a comfortable control the
          system mouse cursor. By specifying .movementX/Y in the same units
          mouse lock API applications will be instantly usable to all users
          because they have already settled their preferences.
        </p>
        <p>
          Secondly, the implementation of providing movement data and bounding
          the mouse cursor is more difficult in the fine grained approach.
          Bundling the features together gives implementations freedom to use a
          variety of techniques as appropriate on each operating system and is
          more practical to implement. Direct APIs do not exist on major
          desktop platforms (Windows, Mac OS X, Linux) to bound the cursor to a
          specific rectangle, and prototypes have not yet been developed to
          demonstrate building that behavior by e.g. <a href=
          "https://tronche.com/gui/x/xlib/window/attributes/">invisible
          windows</a> with <a href=
          "https://en.wikipedia.org/wiki/Xlib">Xlib</a> or manual cursor
          movement on Mac. Unaccelerated Delta values have been proposed to be
          accessed by reading raw Human Interface Device (HID) data. E.g.
          WM_INPUT messages on Windows, and USB device APIs on Mac OS X /
          Linux. The challenge here is interpreting and normalizing the units
          to some consistent and specifiable scale. Also, most APIs considered
          to date are limited to USB devices.
        </p>
        <p>
          It would be reasonable to consider adding these capabilities in the
          future, as the currently specified pointer lock API would be easy to
          continue to support if the finer grained delta and confinement
          features were implemented.
        </p>
        <p>
          The bundled API is selected for implementation practicality, because
          the desired use cases are supported, and because it will not conflict
          with future improvements as discussed here.
        </p>
      </section>
      <section>
        <h2>
          High resolution deltas / High frequency updates?
        </h2>
        <p>
          Not yet, for the same reasons in the previous question: <a href=
          "#why-bundle">"Why bundle all functionality (hiding cursor, providing
          mouse deltas) instead of using CSS to hide the cursor, always
          providing delta values, and offering an API to restrict the cursor
          movement to a portion of the web page?"</a>.
        </p>
      </section>
      <section>
        <h2>
          Why modify MouseEvent and reuse existing mouse events instead of
          creating a mouse delta event?
        </h2>
        <p>
          When under pointer lock many mouse events remain relevant, e.g.
          click, mousedown, etc. These all share the same event data structure
          MouseEvent. If movement data were reported via a new data structure
          then a new event would be needed for reporting delta movement. The
          new data structure would have many parallels to MouseEvent to offer
          the same conveniences, e.g. button and modifier key states. When
          handling click, down, and up events would the existing mousedown,
          mouseup be used? If so, they would provide .clientX/Y and .screenX/Y
          with no useful data, but would lack the convenience of containing the
          current movement data. Or, new events would also be required for when
          the mouse is locked.
        </p>
        <p>
          Also, movementX/Y are convenient even when the mouse is not locked.
          This spec requires movement members to always be valid, even when the
          mouse cursor exists. This reduces code required to track the last
          cursor state and mouseover/mouseout transitions if applications wish
          to make use of delta motion of the mouse.
        </p>
        <p>
          The only negative of adding movementX/Y to MouseEvent appears to be
          the unused values in clientX/Y and screenX/Y when under pointer lock.
          This does not seem to be a significant problem.
        </p>
        <p>
          Therefore the minimal change to add movementX/Y to MouseEvent is
          selected to reduce API and implementation complexity.
        </p>
      </section>
      <section>
        <h2>
          Why separate targets for mouse events under pointer lock and keyboard
          input focus?
        </h2>
        <p>
          Consider a game with a 3D view controlled by moving the mouse cursor,
          while the user may still chat with other users via a text console. It
          is reasonable for the application to accept text input to an element
          that is different than where mouse events are being dispatched. This
          is similar to pre-existing behavior of receiving mousemove events
          over any element while typing into a form on a page.
        </p>
      </section>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
    </section>
    <section class='appendix informative'>
      <h2>
        Acknowledgments
      </h2>
      <p>
        Many thanks to lots of people who made contributions to the discussions
        of this specification:
      </p>
      <ul>
        <li>Adam Barth
        </li>
        <li>Alexey Proskuryakov
        </li>
        <li>Aryeh Gregor
        </li>
        <li>Boris Zbarsky
        </li>
        <li>Brandon Andrews
        </li>
        <li>Darin Fisher
        </li>
        <li>Dimitri Glazkov
        </li>
        <li>Ella Ge
        </li>
        <li>Glenn Maynard
        </li>
        <li>Gregg Tavares
        </li>
        <li>Janice Shiu
        </li>
        <li>John Villar
        </li>
        <li>Jonas Sicking
        </li>
        <li>Kagami Sascha Rosylight
        </li>
        <li>Klaas Heidstra
        </li>
        <li>Lonie Watson
        </li>
        <li>Marcos Cceres
        </li>
        <li>Ms2ger
        </li>
        <li>Mustaq Ahmed
        </li>
        <li>Navid Zolghadr
        </li>
        <li>Olli Pettay
        </li>
        <li>Patrick H. Lauke
        </li>
        <li>Philip Jgenstedt
        </li>
        <li>Philippe Le Hegaret
        </li>
        <li>Robert O'Callahan
        </li>
        <li>Tab Atkins Jr.
        </li>
        <li>Takayoshi Kochi
        </li>
        <li>Timeless
        </li>
        <li>Vincent Scheib
        </li>
        <li>Xiaoqian Wu
        </li>
        <li>Yves Lafon
        </li>
      </ul>
    </section>
  </body>
</html>
